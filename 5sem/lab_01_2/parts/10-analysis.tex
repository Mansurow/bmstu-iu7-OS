\setcounter{page}{2}
\chapter{Функции системного таймера в системах разделения времени}

\section{Функции системного таймера в семействе ОС Windows}

\subsection*{По тику}
\begin{itemize}
	\item инкремент счетчика реального времени;
	\item декремент кванта текущего потока;
	\item декремент счетчиков времени до выполнения отложенных задач.
	 %(декремент происходит на величину, равную кол-ву тактов процессора, произошедших за тик. В случае, если количество затраченных потомков тактов процессора достигает квантовой цели, запускается обработка истечения кванта)
\end{itemize}

\subsection*{По главному тику}
\begin{itemize}
	\item Инициализация диспетчера настройки баланса путем сбрасывания объекта <<событие>>, на котором он ожидает.
\end{itemize}

\subsection*{По кванту}
\begin{itemize}
	\item Инициация диспетчеризации потоков --- постановка соответствующего объекта в очередь DPC.
\end{itemize}



\section{Функции системного таймера в семействе ОС Unix} %\cite{unix}

\subsection*{По тику}

\begin{itemize}
	\item инкремент счетчика времени с момента запуска системы (SVR4, переменная \textit{lbolt})
	\item инкремент счетчика реального времени; %(то есть инкремент поля p\_cpu структуры proc до максимального значения -- 127)
	\item декремент счетчиков времени и при достижении счетчиками нулевого значение установка флага для обработчиков отложенных вызовов;
	\item инкремент счетчика процессорного времени, полученного процессором в режиме задачи и в режиме ядра.
\end{itemize}

\subsection*{По главному тику}

\begin{itemize}
	\item инициализация отложенного вызова функции планировщика;
	\item инициализация отложенного вызова процедуры wakeup, котораяменяет состояние процесса с <<спящий>> на <<готовый к выполнению>>;
	В системе SVR4 можно инициализировать отложенный вызов с помощью timeout(void (*fn)(), caddr\_t arg, long delta); где fn() -- функция, которую необходимо запустить, arg -- аргументы, которые получит fn(), delta -- временный интервал (в тиках процессора) через который fn() должна быть вызвана.
	
	\item пробуждение системных процессов, таких как pagedaemon.
	
	\item декремент счетчика времени, которое осталось до посылки одного из следующих сигналов:
	\begin{itemize}
		\item SIGVTALRM – сигнал, посылаемый процессу по истечении промежутка реального времени;
		\item SIGPROF – сигнал, посылаемый процессу по истечении времени, заданного в таймере профилирования;
		\item SIGALRM – сигнал, посылаемый процессу по истечении времени, заданного в <<виртуальном>> таймере.	
	\end{itemize}
\end{itemize}

\subsection*{По кванту}

\begin{itemize}
	\item посылка сигнала SIGXCPU текущему процессу, если он превысил выделенную для него квоту процессорного времени.
\end{itemize}

\clearpage



\chapter{Пересчет динамических приоритетов}

Системы семейств Unix и Windows являются системами разделения времени с динамическими приоритетами и вытеснением. Динамические приоритеты могут иметь только пользовательские процессы, другие процессы имеют фиксированные приоритеты.

\section{Системы семейства Windows}

В Windows при создании процесса, ему назначается приоритет. Относительно приоритета процесса потоку назначается относительный приоритет.

Планирование осуществляется на основании приоритетов потоков, готовых к выполнению. Поток с более низким приоритетом вытесняется планировщиком, когда поток с более высоким приоритетом становится готовым к выполнению. По истечению кванта времени текущего потока, ресурс передается первому --- самому приоритетному --- потоку в очереди готовых на выполнение.

Раз в секунду диспетчер настройки баланса сканирует очередь готовых потоков. Если обнаружены потоки, ожидающие выполнения более 4 секунд, диспетчер настройки баланса повышает их приоритет. Как только квант истекает, приоритет потока снижается до базового приоритета. Если поток не был завершен за квант времени или был вытеснен потоком с более высоким приоритетом, то после снижения приоритета поток возвращается в очередь готовых потоков.

Чтобы минимизировать расход процессорного времени, диспетчер настройки баланса сканирует лишь 16 готовых потоков. Кроме того, диспетчер повышает приоритет не более чем у 10 потоков за один проход: обнаружив 10 потоков, приоритет которых следует повысить, он прекращает сканирование. При следующем проходе сканирование возобновляется с того места, где оно было прервано в прошлый раз. Наличие 10 потоков, приоритет которых следует повысить, говорит о необычно высокой загруженности системы.

В Windows предусмотренно 32 уровня приоритета:
\begin{itemize}
	\item приоритет 31 --- наивысший;
	
	\item от 16 до 31 --- процессы реального времени;
	
	\item от 0 до 15 --- динамические уровни;
	
	\item 0 --- зарезервирован для процесса обнууления страниц.
	
\end{itemize}

Уровни приоритета потоков назначаются исходя из двух разных позиций: одной от Windows API и другой от ядра Windows. Сначала Windows API систематизирует процессы по классу приоритета, который им присваивается при создании:
\begin{itemize}
	\item Реального времени — Real-time (4)
	\item Высокий — High (3)
	\item Выше обычного — Above Normal (6)
	\item Обычный — Normal (2)
	\item Ниже обычного — Below Normal (5)
	\item Простоя — Idle (1)
\end{itemize}

Уровни приоритета потоков назначаются с двух позиций: Windows API и ядра операционной системы. Windows API сортирует процессы по классам приоритета, которые были назначены при из создании:

\begin{itemize}
	\item реального времени (real-time, 4);
	\item высокий (high, 3);
	\item выше обычного (above normal, 6);
	\item обычный (normal, 2);
	\item ниже обычного (below normal, 5);
	\item простой (idle, 1).
\end{itemize}

Затем назначается относительный приоритет потоков в рамках процесса:

\begin{itemize}
	\item критичный по времени (time critical, 15);
	\item наивысший (highest, 2);
	\item выше обычного (above normal, 1);
	\item обычный (normal, 0);
	\item ниже обычного (below normal, -1);
	\item низший (lowest, -2);
	\item простой (idle, -15).
\end{itemize}

Соответствие между приоритетами Windows API и ядра системы приведено в таблице \ref{tbl:priority}.


\begin{table}[h]
	\caption{Соответствие между приоритетами \textbf{Windows API} и ядра Windows}
	\begin{center}
		\begin{tabular}{|l|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|}
			\hline
			{} & \textbf{real-time} & \textbf{high} & \textbf{above normal} & \textbf{normal} & \textbf{below normal} & \textbf{idle}\\
			\hline
			\textbf{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
			\hline
			\textbf{highest} & 26 & 15 & 12 & 10 & 8 & 6 \\
			\hline
			\textbf{above normal} & 25 & 14 & 11 & 9 & 7 & 5 \\
			\hline
			\textbf{normal} & 24 & 13 & 10 & 8 & 6 & 4 \\
			\hline
			\textbf{below normal} & 23 & 12 & 9 & 7 & 5 & 3 \\
			\hline
			\textbf{lowest} & 22 & 11 & 8 & 6 & 4 & 2 \\
			\hline
			\textbf{idle} & 16 & 1 & 1 & 1 & 1 & 1 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:priority}
\end{table}

Текущий приоритет потока в динамическом диапазоне может быть повышен планировщиком вследствие следующих причин:

\begin{itemize}
	\item завершение операций ввода-вывода;
	\item повышение приоритета владельца блокировки;
	\item ввод из пользовательского интерфейса;
	\item длительное ожидание ресурса исполняющей системы;
	\item ожидание объекта ядра;
	\item готовый к выполнению поток не был запущен в течение длительного времени;
	\item повышение приоритета службой планировщика MMCSS.
\end{itemize}

\begin{table}[h!]
	\caption{Рекомендуемые значения повышения приоритета.}
	\begin{center}
		\begin{tabular}{|p{100mm}|l|}
			\hline
			\textbf{Устройство} & \textbf{Приращение} \\
			\hline
			Диск, CD-ROM, параллельный порт, видео & 1 \\
			\hline
			Сеть, почтовый ящик, именованный канал, последовательный порт & 2 \\
			\hline
			Клавиатура, мышь & 6 \\
			\hline
			Звуковая плата & 8 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tab:io}
\end{table}

Текущий приоритет потока в динамическом диапазоне может быть понижен до базового приоритета путем вычитания всех повышений.

\subsection*{MMCSS}

Потоки, на которых выполняются различные мультимедийные приложения, должны выполняться с минимальными задержками. В Windows эта задача решается путем повышения приоритетов таких потоков драйвером MMCSS -- MultiMedia Class Scheduler Service. Приложения, которые реализуют воспроизведение мультимедиа, указывают драйверу MMCSS задачу из списка:

\begin{enumerate}[]
	\item аудио;
	\item возможность использовать функции записи;
	\item воспроизведение звукового или видео контента;
	\item задачи администратора многооконного режима.
\end{enumerate}

Одно из наиболее важных свойств для планирования потоков --- категория планирования --- первичный фактор определяющий приоритет потоков, зарегистрированных в MMCSS. Различные категории планирования представленны в таблице ниже.

\begin{table}[h!]
	\caption{Категории планирования.}
	\begin{center}
		\begin{tabular}{|p{40mm}|p{30mm}|p{80mm}|}
			\hline
			\textbf{Категория} & \textbf{Приоритет} & \textbf{Описание} \\
			\hline
			High (Высокая) & 23-26 & Потоки профессионального аудио (Pro Audio), запущенные с приоритетом выше, чем у других потоков на системе, за исключением критических системных потоков \\
			\hline
			Medium (Средняя) & 16-22 & Потоки, являющиеся частью приложений первого плана, например Windows Media Player \\
			\hline
			Low (Низкая) & 8-15 & Все остальные потоки, не являющиеся частью предыдущих категорий \\
			\hline
			Exhausted (Исчерпавших потоков) & 1-7 & Потоки, исчерпавшие свою долю времени центрального процессора, выполнение которых продолжиться, только если не будут готовы к выполнению другие потоки с более высоким уровнем приоритета \\
			\hline
		\end{tabular}
	\end{center}
	\label{tab:plan}
\end{table}

Функции MMCSS временно повышают приоритет потоков, зарегистрированных с MMCSS до уровня, соответствующего их категориям планирования. Далее, их приоритет снижается до уровня, соответствующего категории Exhausted, для того чтобы другие потоки могли получить ресурс.

\subsection*{IRQL}

Хотя контроллеры прерываний устанавливают приоритетность прерываний, Windows устанавливает свою собственную схему приоритетности прерываний, известную как уровни запросов прерываний (IRQL). В ядре IRQL-уровни представлены в виде номеров от 0 до 31 (рисунок \ref{fig:irql}), где более высоким номерам соответствуют прерывания с более высоким приоритетом.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.90\linewidth]{inc/img/irql.png}
	\caption{Уровни запросов прерываний}
	\label{fig:irql}
\end{figure}

Прерывания обслуживаются в порядке их приоритета. При возникновении прерывания с высоким приоритетом процессор сохраняет информацию о состоянии прерванного потока и запускает связанные с прерывание диспетчер системных прерываний.

\clearpage


\section{Системы семейства Unix}

Планирование процессов в UNIX основано на приоритете процесса. Планировщик всегда выбирает процесс с наивысшим приоритетом. Приоритеты планирования изменяются с течением времени (динамически) системой в зависимости от использования вычислительных ресурсов, времени ожидания запуска и текущего состояния процесса. 

Традиционное ядро UNIX является строго невытесняющим, однако в современных системах UNIX ядро является вытесняющим -- то есть процесс в режиме ядра может быть вытеснет более приоритетным процессом в режиме ядра. Ядро сделано вытесняющим для того, чтобы система могла обслуживать процессы реального времени, например видео и аудио.

Очередь процессов, готовых к выполнению, формируется согласно приоритетам и принципу вытесняющего циклического планирования, то есть сначала выполняются процессы с большим приоритетом, а процессы с одинаковым приоритетом выполняются в течении кванта времени друг за другом циклически. В случае, если процесс с более высоким приоритетом поступает в очередь процессов, готовых к выполнению, планировщик вытесняет текущий процесс и предоставляет ресурс более приоритетному процессу.

Приоритет процесса задается любым целым числом, которое лежит в диапазоне от 0 до 127 (чем меньше число, тем выше приоритет)
\begin{itemize}
	\item 0 - 49 -- зарезервированы для ядра (приоритеты ядра фиксированы)
	\item 50 - 127 -- прикладные  (приоритеты прикладных задач могут изменяться во времени)
\end{itemize}

Изменение приоритета прикладных задач зависит от следующих факторов:
\begin{itemize}
	\item фактор 'любезности';
	\item последней измеренной величины использования процессора.
\end{itemize}

\noindent Фактор любезности -- это целое число в диапазоне от 0 до 39 (по умолчанию 20). Чем меньше значение фактора любезности процесса, тем выше приоритет процесса. Фактор любезности процесса может быть изменен с помощью системного вызова \textbf{nice}, но только суперпользователем. Фоновым процессам задаются более высокие значения фактора любезности.

Дескриптор процесса proc содержит следующие поля, которые относятся к приоритетам:
\begin{itemize}
	\item p\_pri -- текущий приоритет планирования
	\item p\_usrpri -- приоритет режима задачи
	\item p\_cpu -- результат последнего измерения использования процессора
	\item p\_nice -- фактор 'любезности', который устанавливается пользователем
\end{itemize}

\textbf{p\_pri} используется планировщиком для принятия решения о том, какой процесс отправиьь на выполнение. \textbf{p\_pri} и \textbf{p\_usrpri} равны, когда процесс находится в режиме задачи. 

Значение \textbf{p\_pri} может быть изменено (повышено) планировщиком для того, чтобы выполнить процесс в режиме ядра. В таком случае \textbf{p\_usrpri} будет использоваться для хранения приоритета, который будет назначен процессу, когда тот вернется в режим задачи.

\textbf{p\_cpu} инициализируется нулем при создании процесса (и на каждом тике обработчик таймера увеличивает это поле текущего процесса на 1, до максимального значения равного 127).

Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом, из-за которого процесс может блокироваться (приоритет сна определяется для ярда, поэтому лежит в диапазоне 0 - 49). Когда процесс 'просыпается', ядро устанавливает \textbf{p\_pri}, равное приоритету сна события или ресурса, по которому произошла блокировка (значение приоритета сна для некоторых событий в системе 4.3BSD представлены в таблице \ref{tab:bsd}).


\begin{table}[h!]
	\caption{Приоритеты
		сна в ОС \textbf{4.3BSD}}
	\label{tab:bsd}
	\begin{center}
		\begin{tabular}{ |c|c|c|  }
			\hline
			\textbf{Приоритет} & \textbf{Значение} & \textbf{Описание} \\
			\hline
			\texttt{PSWP} & 0 & Свопинг \\
			\hline
			\texttt{PSWP + 1} & 1 & Страничный демон \\
			\hline
			\texttt{PSWP + 1/2/4} & 1/2/4 & Другие действия по обработке памяти \\
			\hline
			\texttt{PINOD} & 10 & Ожидание освобождения inode \\
			\hline
			\texttt{PRIBIO} & 20 & Ожидание дискового ввода-вывода \\
			\hline
			\texttt{PRIBIO + 1} & 21 & Ожидание освобождения буфера \\
			\hline
			\texttt{PZERO} & 25 & Базовый приоритет \\
			\hline
			\texttt{TTIPRI} & 28 & Ожидание ввода с терминала \\
			\hline
			\texttt{TTOPRI} & 29 & Ожидание вывода с терминала \\
			\hline 
			\texttt{PWAIT} & 30 & Ожидание завершения процесса потомка \\
			\hline
			\texttt{PLOCK} & 35 & Консультативное ожидание блок. ресурса \\
			\hline
			\texttt{PSLEP} & 40 & Ожидание сигнала \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Также приведена таблица из книги <<Операционная система UNIX>> Андрея Робачевского на рисунке \ref{fig:rob}. Заметим, что направление роста значений приоритета для этих систем (4.3BSD UNIX и SCO UNIX) различно.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.90\linewidth]{inc/img/sleep.png}
	\caption{Системные приоритеты сна}
	\label{fig:rob}
\end{figure}

\clearpage

Каждую секунду ядро системы инициализирует отложенный вызов процедуры schedcpu(), которая уменьшает значение \textbf{p\_pri} каждого процесса исходя из фактора ''полураспада'' (в системе 4.3BSD считается по формуле \ref{eq:ref1})

\begin{equation}
\label{eq:ref1}
decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1}
\end{equation} где
\textit{load\_average} - это среднее количество процессов, находящихся в состоянии готовности к выполнению, за последнюю секунду.

Также процедура schedcpu() пересчитывает приоритеты для режима задачи
всех процессов по формуле \ref{eq:ref2},

\begin{equation}
\label{eq:ref2}
p\_usrpri = PUSER + \frac{p\_cpu}{2} + 2 \cdot p\_nice
\end{equation}где \textit{PUSER} - базовый приоритет в режиме задачи, равный 50.

Таким образом, если процесс в последний раз использовал большое количество процессорного времени, то его р\_срu будет увеличен => рост значения p\_usrpri => понижение приоритета.  Чем дольше процесс простаивает в очереди на выполнение, тем больше фактор полураспада уменьшает его р\_срu => повышение его приоритета. Такая схема предотвращает бесконечное откладывание низкоприоритетных процессов. Применение данной схемы предпочтительно процессам, осуществляющим много операций ввода-вывода, в противоположность процессам, производящим много вычислений. То есть динамический пересчет приоритетов процессов в режиме задачи позволяет избежать бесконечного откладывания.



\chapter{Вывод}

Операционные системы семейств Unix и Windows являются системами разделения времени с динамическими приоритетами и вытеснением, поэтому функции обработчика прерывания от системного таймера в этих системах выполняют схожие задачи:

\begin{itemize}
	\item декремент кванта текущего процесса в UNIX и декремент текущего потока в Windows.
	\item инициализация отложенных действий, которые относятся к работе планировщика (например, пересчет приоритетов).
	\item декремент счетчиков времени (таймеров, часов, счетчиков времени отложенных действий, будильников реального времени) 
\end{itemize}

Пересчет динамических приоритетов осуществляется только для пользовательских процессов для того, чтобы избежать бесконечного откладывания.








